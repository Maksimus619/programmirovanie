#include <SFML/Graphics.hpp>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <chrono>
#include <thread>

const int gridSize = 15;
const int cellSize = 30;
const int initialPlayerSize = 3;
const int maxPlayerCells = 10;
const float splitCooldown = 0.5f;
const float mergeCooldown = 5.0f;

sf::RenderWindow window(sf::VideoMode(gridSize * cellSize, gridSize * cellSize), "Agario Lite");

struct Cell {
    sf::RectangleShape shape;
    sf::Vector2f velocity;
    bool canSplit;
    bool canMerge;
};

std::vector<Cell> playerCells;
std::vector<Cell> foodCells;
std::vector<Cell> enemyCells;

int score = 0;

void initializeGame() {
    srand(time(0));

    playerCells.clear();
    foodCells.clear();
    enemyCells.clear();

    for (int i = 0; i < initialPlayerSize; ++i) {
        Cell cell;
        cell.shape.setSize(sf::Vector2f(cellSize, cellSize));
        cell.shape.setFillColor(sf::Color::Green);
        cell.shape.setPosition(rand() % gridSize * cellSize, rand() % gridSize * cellSize);
        cell.canSplit = true;
        cell.canMerge = true;
        playerCells.push_back(cell);
    }

    for (int i = 0; i < gridSize * 2; ++i) {
        Cell cell;
        cell.shape.setSize(sf::Vector2f(cellSize, cellSize));
        cell.shape.setFillColor(sf::Color::Red);
        cell.shape.setPosition(rand() % gridSize * cellSize, rand() % gridSize * cellSize);
        foodCells.push_back(cell);
    }

    for (int i = 0; i < gridSize; ++i) {
        Cell cell;
        cell.shape.setSize(sf::Vector2f(cellSize, cellSize));
        cell.shape.setFillColor(sf::Color::Blue);
        cell.shape.setPosition(rand() % gridSize * cellSize, rand() % gridSize * cellSize);
        enemyCells.push_back(cell);
    }
}

void handleInput() {
    sf::Event event;
    while (window.pollEvent(event)) {
        if (event.type == sf::Event::Closed)
            window.close();
    }

    float speed = 5.0f;

    if (sf::Keyboard::isKeyPressed(sf::Keyboard::W)) {
        playerCells[0].velocity = sf::Vector2f(0, -speed);
    }
    if (sf::Keyboard::isKeyPressed(sf::Keyboard::S)) {
        playerCells[0].velocity = sf::Vector2f(0, speed);
    }
    if (sf::Keyboard::isKeyPressed(sf::Keyboard::A)) {
        playerCells[0].velocity = sf::Vector2f(-speed, 0);
    }
    if (sf::Keyboard::isKeyPressed(sf::Keyboard::D)) {
        playerCells[0].velocity = sf::Vector2f(speed, 0);
    }

    if (sf::Keyboard::isKeyPressed(sf::Keyboard::Space)) {
        splitPlayer();
    }
}

void splitPlayer() {
    if (playerCells.size() < maxPlayerCells && playerCells[0].canSplit) {
        Cell newCell;
        newCell.shape.setSize(sf::Vector2f(cellSize, cellSize));
        newCell.shape.setFillColor(sf::Color::Green);
        newCell.shape.setPosition(playerCells[0].shape.getPosition());
        newCell.canSplit = false;
        newCell.canMerge = false;
        playerCells.push_back(newCell);

        playerCells[0].canSplit = false;
        std::this_thread::sleep_for(std::chrono::seconds(static_cast<int>(splitCooldown)));
        playerCells[0].canSplit = true;
    }
}

void mergePlayer() {
    if (playerCells.size() > 1 && playerCells[0].canMerge) {
        playerCells.pop_back();

        playerCells[0].canMerge = false;
        std::this_thread::sleep_for(std::chrono::seconds(static_cast<int>(mergeCooldown)));
        playerCells[0].canMerge = true;
    }
}

void updatePlayer() {
    for (size_t i = playerCells.size() - 1; i > 0; --i) {
        playerCells[i].shape.setPosition(playerCells[i - 1].shape.getPosition());
    }

    playerCells[0].shape.move(playerCells[0].velocity);

    for (auto& cell : playerCells) {
        if (cell.shape.getPosition().x < 0) {
            cell.shape.setPosition(window.getSize().x, cell.shape.getPosition().y);
        }
        if (cell.shape.getPosition().x >= window.getSize().x) {
            cell.shape.setPosition(0, cell.shape.getPosition().y);
        }
        if (cell.shape.getPosition().y < 0) {
            cell.shape.setPosition(cell.shape.getPosition().x, window.getSize().y);
        }
        if (cell.shape.getPosition().y >= window.getSize().y) {
            cell.shape.setPosition(cell.shape.getPosition().x, 0);
        }
    }
}

void updateEnemies() {
    for (auto& enemy : enemyCells) {
        sf::Vector2f direction = playerCells[0].shape.getPosition() - enemy.shape.getPosition();
        float length = std::sqrt(direction.x * direction.x + direction.y * direction.y);

        direction /= length;

        enemy.velocity = direction * 3.0f;
        enemy.shape.move(enemy.velocity);

        for (size_t i = 1; i < playerCells.size(); ++i) {
            if (playerCells[i].shape.getGlobalBounds().intersects(enemy.shape.getGlobalBounds())) {
                playerCells[i].shape.setPosition(rand() % gridSize * cellSize, rand() % gridSize * cellSize);
                score--;
            }
        }
    }
}

void checkCollision() {
    for (size_t i = 0; i < foodCells.size(); ++i) {
        if (playerCells[0].shape.getGlobalBounds().intersects(foodCells[i].shape.getGlobalBounds())) {
            foodCells[i].shape.setPosition(rand() % gridSize * cellSize, rand() % gridSize * cellSize);
            playerCells.push_back(foodCells[i]);
            foodCells.erase(foodCells.begin() + i);
            score++;
        }
    }

    for (size_t i = 1; i < playerCells.size(); ++i) {
        if (playerCells[0].shape.getGlobalBounds().intersects(playerCells[i].shape.getGlobalBounds())) {
            if (playerCells[0].shape.getSize().x > playerCells[i].shape.getSize().x * 2 &&
                playerCells[0].shape.getSize().y > playerCells[i].shape.getSize().y * 2) {
                // Player can eat the other cell
                playerCells.erase(playerCells.begin() + i);
            } else {
                std::cout << "Game Over! Score: " << score << std::endl;
                window.close();
            }
        }
    }
}

int main() {
    initializeGame();

    while (window.isOpen()) {
        handleInput();
        updatePlayer();
        updateEnemies();
        checkCollision();

        window.clear();

        for (const auto& cell : playerCells) {
            window.draw(cell.shape);
        }

        for (const auto& cell : foodCells) {
            window.draw(cell.shape);
        }

        for (const auto& cell : enemyCells) {
            window.draw(cell.shape);
        }

        sf::Font font;
        if (!font.loadFromFile("arial.ttf")) {
            // handle error
        }

        sf::Text scoreText;
        scoreText.setFont(font);
        scoreText.setString("Score: " + std::to_string(score));
        scoreText.setCharacterSize(24);
        scoreText.setFillColor(sf::Color::White);
        scoreText.setPosition(10, 10);

        window.draw(scoreText);

        window.display();
    }

    return 0;
}
